const preload = () => {
  let manager = new THREE.LoadingManager();
  manager.onLoad = function () {
    const environment = new Environment(typo, particle);
  };

  var typo = null;
  const loader = new THREE.FontLoader(manager);
  const font = loader.load(
    "https://res.cloudinary.com/dydre7amr/raw/upload/v1612950355/font_zsd4dr.json",
    function (font) {
      typo = font;
    }
  );
  const particle = new THREE.TextureLoader(manager).load(
    "https://res.cloudinary.com/dfvtkoboz/image/upload/v1605013866/particle_a64uzf.png"
  );
};

if (
  document.readyState === "complete" ||
  (document.readyState !== "loading" && !document.documentElement.doScroll)
)
  preload();
else document.addEventListener("DOMContentLoaded", preload);

class Environment {
  constructor(font, particle) {
    this.font = font;
    this.particle = particle;
    this.container = document.querySelector("#magic");
    this.scene = new THREE.Scene();
    this.createCamera();
    this.createRenderer();
    this.setup();
    this.bindEvents();
  }

  bindEvents() {
    window.addEventListener("resize", this.onWindowResize.bind(this));
    window.addEventListener("scroll", this.onScroll.bind(this));
  }

  setup() {
    this.createParticles = new CreateParticles(
      this.scene,
      this.font,
      this.particle,
      this.camera,
      this.renderer
    );
  }

  render() {
    this.createParticles.render();
    this.renderer.render(this.scene, this.camera);
  }

  createCamera() {
    this.camera = new THREE.PerspectiveCamera(
      65,
      this.container.clientWidth / this.container.clientHeight,
      1,
      10000
    );
    this.camera.position.set(0, 0, 100);
  }

  createRenderer() {
    this.renderer = new THREE.WebGLRenderer();
    this.renderer.setSize(
      this.container.clientWidth,
      this.container.clientHeight
    );

    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    this.renderer.outputEncoding = THREE.sRGBEncoding;
    this.container.appendChild(this.renderer.domElement);

    this.renderer.setAnimationLoop(() => {
      this.render();
    });
  }

  onScroll(e) {
    this.camera.position.set(0, -window.scrollY / 10, 100);
    this.camera.updateProjectionMatrix();
  }

  onWindowResize() {
    this.camera.aspect =
      this.container.clientWidth / this.container.clientHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(
      this.container.clientWidth,
      this.container.clientHeight
    );
  }
}

class CreateParticles {
  constructor(scene, font, particleImg, camera, renderer) {
    this.scene = scene;
    this.font = font;
    this.particleImg = particleImg;
    this.camera = camera;
    this.renderer = renderer;

    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2(-200, 200);

    this.colorChange = new THREE.Color();

    this.buttom = false;

    this.data = {
      text: `Through a distorted lens
closed-eye impressions of fluid smudges.

A larger definition beats into existence, a planet seen through bulging windows.
Across its surface clouds of chemical reaction break with cords of impossible light.
Through breaks in the cloud, glimpses of a stagnant ocean curdled with islands of froth;
valleys that spiral into themselves like imprints of conical shells,
whipped up by winds into blizzards of calcium dust.

Around me a coordinated array of small translucent vessels are beginning their descent into the planet's atmosphere.
They appear like see-through seed pods with irregular bulges and grooves segmented by two radial ridges like a walnut.

My body, like the millions of others sitting at the consoles of the ships,
is strange. I am made of dark ribbons, flax-like tape strung together into a
loose stick figure.

I move my arms which flail and fold with every movement, slightly sinking into the walls.
I feel an evil coldness as my foot touches something within the floor.
Erupting from my feet, impressions bulging in backed-up pipes on their way to my brain, arriving in deep rhythmic glugs of feeling.
I relax my pose and curl the reeds of my feet which stops them sinking into the floor.

Within nearby ships figures battle against the force of entry, their limbs rippling in wild frequencies.
One of the figures has merged with the back wall and is being pushed through.
Forced from the ship it bursts into flames. It appears like a sketch of a scarecrow, a burning symbol against the blackness of space.
A number of the creatures share this fate, their appendages traced now by only a faint glow
and then nothing.

The smell of something burning, something I know well but cannot place, wafts from a dripping grate.
A pitch dark well bored into reality by some unknowable machine, the space it occupies breaks spatial logic of the ship,
opening into a hidden aspect of space.
Inside its impossible depth is suggested by glints of a great triangular metallic shell miles down.
With a breath that is rotten and scorched, it speaks to me.
It describes the lost entities, making importance of their sacrifice, reading meaning from their final shapes like tea leaves.

Breaking the hypnotic monologue, I am aware of a thudding sound.
A nearby figure has walked to the wall of their ship and is facing me, beating the wall with one arm,
the other crooked and low against the stomach - hand out, half-melded with the wall - a single thread of a finger pointing at me.
I look for its face, vision tumbling into empty space as I trace the delicate loop of ribbon that forms its head.

In an instant the figure is gone and all around the once crawling horizon of ships harden into smooth spheres of opaque white.

By some terrible mistake the walls of my ship remain unchanged.

Muffled giggles float from the grate.
Within the well chunks of destroyed material crumbles from the walls, dense networks of wire and tubing severed and falling.

Released from a burden of roots, vague fish-like shapes emerge - pressurized popping as intravenous tubes fall from their flared gills.
Small devices hidden in the walls eject cords with shots of steam and fall softly glowing into darkness.

A splash as some devices land in oily channels, blinking out, swallowed into deeper networks.
Others chime against the architecture below, now dotted with suggestive motes of light,
giving broken glimpses of sculptures and a monolithic platform on which the creature had rested just before.


The creatures breach the grating. Floating unaided in the air the organic vessels look exactly like dead fish rigged with
complex mechanic appendages and
swollen towards the head by something living inside.
Possessed doubled eyes.
The thin lens of a fish eye stirring; within darting red and raw humanoid eyes
squinting to the light.
A smiling blunt-toothed mouth shadowed, peeking out from within the hanging fish maw.
One of the creatures wears a bizarre shiny visor across its eyes and holds its tilted head
in its hands, grinning stupidly.

Floating forward the forms bleed, discolouring the air in unnatural shades.

The fish-like vessels buckle in the center under the weight of hanging devices,
connected by a cord bound so tight it crushes the dorsal fin.

Within the dangling boxes tiny silhouettes move through a cross-section maze of rooms.
Dangling past my face the burning smell is so strong it blossoms with fruity cheesy notes.

In synchronized movements the humanoid heads roll deeper inside the vessel,
eyes in partial eclipse then unblended, the fish head deflated and hollow, swelling into the tail.
Mechanical arms flicker in the air, surgically removing parasites hidden in the folds of gills.

Against the roar of breaking atmosphere, a high scream echoes in layers of harmony before falling into pure silence.
Swimming through space two immense forms dive towards the planet,their flowing triangular capes of fabric like beetle carapaces reflect things
not of this world. Cities buried in transparent tubes, desperate forms with abyssal eyes crawling upwards towards great apertures
of floating organs the size of moons.

Crushing mountains with metallic talons they lift the terrain, a tear of light across the equator, as the land is peeled away in one giant sheet.
Beneath this skin I see what I can only understand to be two embracing human-like bodies forming an orb - the core of the planet.
Out in space the discarded shell is a sail reflecting the gentle light of a sun.

`,
      amount: 100,
      particleSize: 1,
      particleColor: 0xffffff,
      textSize: 2,
      area: 50,
      ease: 0.05,
    };
    this.setup();
    this.bindEvents();
  }

  setup() {
    const geometry = new THREE.PlaneGeometry(
      this.visibleWidthAtZDepth(100, this.camera),
      this.visibleHeightAtZDepth(100, this.camera)
    );
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ff00,
      transparent: true,
    });
    this.planeArea = new THREE.Mesh(geometry, material);
    this.planeArea.visible = false;
    this.createText();
  }

  bindEvents() {
    document.addEventListener("mousedown", this.onMouseDown.bind(this));
    document.addEventListener("mousemove", this.onMouseMove.bind(this));
    // document.addEventListener("mouseup", this.onMouseUp.bind(this));
  }

  onMouseDown(event) {
    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    const vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
    vector.unproject(this.camera);
    const dir = vector.sub(this.camera.position).normalize();
    const distance = -this.camera.position.z / dir.z;
    this.currenPosition = this.camera.position
      .clone()
      .add(dir.multiplyScalar(distance));

    const pos = this.particles.geometry.attributes.position;
    // this.buttom = true;
    this.data.ease = 0.01;
  }

  onMouseUp() {
    // this.buttom = false;
    this.data.ease = 0.05;
  }

  onMouseMove(event) {
    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  }

  render(level) {
    const time = ((0.001 * performance.now()) % 12) / 12;
    const zigzagTime = (1 + Math.sin(time * 2 * Math.PI)) / 6;

    this.raycaster.setFromCamera(this.mouse, this.camera);

    const intersects = this.raycaster.intersectObject(this.planeArea);

    if (intersects.length > 0) {
      const pos = this.particles.geometry.attributes.position;
      const copy = this.geometryCopy.attributes.position;
      const coulors = this.particles.geometry.attributes.customColor;
      const size = this.particles.geometry.attributes.size;

      const mx = intersects[0].point.x;
      const my = intersects[0].point.y;
      const mz = intersects[0].point.z;

      for (var i = 0, l = pos.count; i < l; i++) {
        const initX = copy.getX(i);
        const initY = copy.getY(i);
        const initZ = copy.getZ(i);

        let px = pos.getX(i);
        let py = pos.getY(i);
        let pz = pos.getZ(i);

        this.colorChange.setHSL(0.5, 1, 1);
        coulors.setXYZ(
          i,
          this.colorChange.r,
          this.colorChange.g,
          this.colorChange.b
        );
        coulors.needsUpdate = true;

        size.array[i] = this.data.particleSize;
        size.needsUpdate = true;

        let dx = mx - px;
        let dy = my - py;
        const dz = mz - pz;

        const mouseDistance = this.distance(mx, my, px, py);
        let d = (dx = mx - px) * dx + (dy = my - py) * dy;
        const f = -this.data.area / d;

        if (this.buttom) {
          const t = Math.atan2(dy, dx);
          px -= f * Math.cos(t);
          py -= f * Math.sin(t);

          this.colorChange.setHSL(0.5 + zigzagTime, 1.0, 0.5);
          coulors.setXYZ(
            i,
            this.colorChange.r,
            this.colorChange.g,
            this.colorChange.b
          );
          coulors.needsUpdate = true;

          if (
            px > initX + 70 ||
            px < initX - 70 ||
            py > initY + 70 ||
            py < initY - 70
          ) {
            this.colorChange.setHSL(0.15, 1.0, 0.5);
            coulors.setXYZ(
              i,
              this.colorChange.r,
              this.colorChange.g,
              this.colorChange.b
            );
            coulors.needsUpdate = true;
          }
        } else {
          if (mouseDistance < this.data.area) {
            if (i % 5 == 0) {
              const t = Math.atan2(dy, dx);
              px -= 0.03 * Math.cos(t);
              py -= 0.03 * Math.sin(t);

              this.colorChange.setHSL(0.15, 1.0, 0.5);
              coulors.setXYZ(
                i,
                this.colorChange.r,
                this.colorChange.g,
                this.colorChange.b
              );
              coulors.needsUpdate = true;

              size.array[i] = this.data.particleSize / 1.2;
              size.needsUpdate = true;
            } else {
              const t = Math.atan2(dy, dx);
              px += f * Math.cos(t);
              py += f * Math.sin(t);

              pos.setXYZ(i, px, py, pz);
              pos.needsUpdate = true;

              size.array[i] = this.data.particleSize * 1.3;
              size.needsUpdate = true;
            }

            if (
              px > initX + 10 ||
              px < initX - 10 ||
              py > initY + 10 ||
              py < initY - 10
            ) {
              this.colorChange.setHSL(0.15, 1.0, 0.5);
              coulors.setXYZ(
                i,
                this.colorChange.r,
                this.colorChange.g,
                this.colorChange.b
              );
              coulors.needsUpdate = true;

              size.array[i] = this.data.particleSize / 1.8;
              size.needsUpdate = true;
            }
          }
        }

        px += (initX - px) * this.data.ease;
        py += (initY - py) * this.data.ease;
        pz += (initZ - pz) * this.data.ease;

        pos.setXYZ(i, px, py, pz);
        pos.needsUpdate = true;
      }
    }
  }

  createText() {
    let thePoints = [];

    let shapes = this.font.generateShapes(this.data.text, this.data.textSize);
    let geometry = new THREE.ShapeGeometry(shapes);
    geometry.computeBoundingBox();

    const xMid =
      -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
    const yMid =
      (geometry.boundingBox.max.y - geometry.boundingBox.min.y) / 4.85;

    geometry.center();

    let holeShapes = [];

    for (let q = 0; q < shapes.length; q++) {
      let shape = shapes[q];

      if (shape.holes && shape.holes.length > 0) {
        for (let j = 0; j < shape.holes.length; j++) {
          let hole = shape.holes[j];
          holeShapes.push(hole);
        }
      }
    }
    shapes.push.apply(shapes, holeShapes);

    let colors = [];
    let sizes = [];

    for (let x = 0; x < shapes.length; x++) {
      let shape = shapes[x];

      const amountPoints =
        shape.type == "Path" ? this.data.amount / 2 : this.data.amount;

      let points = shape.getSpacedPoints(amountPoints);

      points.forEach((element, z) => {
        const a = new THREE.Vector3(element.x, element.y, 0);
        thePoints.push(a);
        colors.push(this.colorChange.r, this.colorChange.g, this.colorChange.b);
        sizes.push(1);
      });
    }

    let geoParticles = new THREE.BufferGeometry().setFromPoints(thePoints);
    geoParticles.translate(xMid, yMid, 0);

    geoParticles.setAttribute(
      "customColor",
      new THREE.Float32BufferAttribute(colors, 3)
    );
    geoParticles.setAttribute(
      "size",
      new THREE.Float32BufferAttribute(sizes, 1)
    );

    const material = new THREE.ShaderMaterial({
      uniforms: {
        color: { value: new THREE.Color(0xffffff) },
        pointTexture: { value: this.particleImg },
      },
      vertexShader: document.getElementById("vertexshader").textContent,
      fragmentShader: document.getElementById("fragmentshader").textContent,

      blending: THREE.AdditiveBlending,
      depthTest: false,
      transparent: true,
    });

    this.particles = new THREE.Points(geoParticles, material);
    this.scene.add(this.particles);

    this.geometryCopy = new THREE.BufferGeometry();
    this.geometryCopy.copy(this.particles.geometry);
  }

  visibleHeightAtZDepth(depth, camera) {
    const cameraOffset = camera.position.z;
    if (depth < cameraOffset) depth -= cameraOffset;
    else depth += cameraOffset;

    const vFOV = (camera.fov * Math.PI) / 180;

    return 2 * Math.tan(vFOV / 2) * Math.abs(depth);
  }

  visibleWidthAtZDepth(depth, camera) {
    const height = this.visibleHeightAtZDepth(depth, camera);
    return height * camera.aspect;
  }

  distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  }
}
